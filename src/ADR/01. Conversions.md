# 01. Conversions and concatenation

Date: 2025-03-01

## Context

The sensitive string type is used to semanticaly mark data items as containing data that we don't want to leak into logs, traces, etc. It shouldn't be considered a type that encrypts text. 

To reduce the risk of leaks, the type hides the underlying string in a local function call. Even if a serializer includes private members of an object, the chances are low it will be calling methods to retrieve data. Thanks to that, serialization without dedicated converters shouldn't rather get access to the hidden value.

We need, however, to take into consideration the ease of use of the type and how prone we are to misuse it ending up in wasted debugging time. So in certain scenarios we want the underlying string to be revealed. Below is a list of decisions made based on experience. They may be changed in the future.

## Decision

1. Implicit conversion from and to string is impossible.
2. Explicit conversion from and to string is possible.
3. `ToString()` returns a masked value.
4. `ToString(format?, IFormatProvider?)` reveals the value when `format` is `null`,
   1. And so does `ToString(format?)`.

5. Concatenation with `string` is possible.
6. Concatenation with `string` returns `string` rather than `SensitiveString`.
7. Equality operator is implemented for `string`.
8. Comparison to `string` compares against the underlying (unmasked) value.
9. A hash code obtained by calling `GetHashCode()` on `SensitiveString` will be different than for the same value accessed as `string`.

## Consequences

1. Implicit conversion from and to string is impossible because it would be very easy then to map data with inconsistent property types and it would get unnoticed.
2. Explicit conversion from and to string is possible to make it easier in some cases to get or convert the underlying data by reflection. Some framework mechanisms attempt to convert property expressions to string to map them to database queries or to specify a validation expression for a string. If the conversion wasn't implemented, the operations would need special handling, which would be cumbersome. Note that SensitiveEmail, the descendant, also has the explicit operator specified redundantly because without it, conversion by reflection on that specific type will fail.
3. ToString() is naturally called to convert a value to string, and this is what we should expect from most serializers or stringifiers to do when they don't know a type. So this method should definitely return a masked value.
4. `ToString(format?, IFormatProvider?)` is used when a sensitive string value is used in string interpolation. If it returns a masked value then, the code will be prone to errors as in most cases when you interpolate a string, you know what you do and getting a masked value as a result could be frustrating and causing a waste of time on debugging why your code doesn't work the way you expect. Still you can get the value masked by specifying an appropriate format.
   1. ToString(format?) is not used in string interpolation, but for consistency works the same as the method above.
5. Concatenation with string is possible for ease of use. Sometimes, e.g. when filtering data by Linq expressions, you concatenate the value searched.
6. Concatenation with string returns string. This decision is controversial because if a piece of text is sensitive, then concatenated with non-sensitive text the result is still sensitive in fact. But the reason behind this decision is that some operations, e.g. filtering EF Core entities by concatenated sensitive strings would cause an exception unless explicitly handled. That causes less readable and unclean code.
7. Equality comparison is possible between string and sensitive string. This one is yet to be checked further in real life scenarios. On one hand it may cause an inconsistency in your code. If your comparand is of the string type, your code is probably inconsistent. Yet this decision gives more flexibility.
8. Comparison to string compares to the actual value rather than a masked one since doing it the other way round would cause an unexpected behavior.
9. Hash codes will be identical for two sensitive string instances with the same underlying string, but when both a string and a sensitive string put in a hash-based collection as objects, their hash codes will be different even if their values are the same. This is to prevent a situation when two objects of a different type are interpreted as the same object.